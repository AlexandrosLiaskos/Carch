#include "cpp_generator.h"
#include <sstream>
#include <algorithm>

namespace carch {
namespace codegen {

CppGenerator::CppGenerator(parser::SchemaNode* schema, const GenerationOptions& options)
    : schema_(schema), options_(options), current_indent_(0) {}

std::string CppGenerator::generate_header() {
    std::ostringstream oss;
    
    // Header guard
    std::string guard = generate_header_guard_name();
    oss << "#pragma once\n";
    oss << "#ifndef " << guard << "\n";
    oss << "#define " << guard << "\n\n";
    
    // Includes
    oss << generate_includes() << "\n";
    
    // Namespace open
    oss << generate_namespace_open() << "\n";
    
    // Entity ID typedef (if using strong entity ID)
    if (options_.use_strong_entity_id && !options_.namespace_name.empty()) {
        oss << indent() << "using entity_id = " << options_.entity_id_typedef << ";\n\n";
    }
    
    // First pass: generate all type definitions to populate hoisted types
    std::vector<std::string> type_defs;
    for (auto& def : schema_->definitions) {
        type_defs.push_back(generate_type_definition(def.get()));
    }
    
    // Generate hoisted anonymous types
    if (!hoisted_types_.str().empty()) {
        oss << hoisted_types_.str() << "\n";
    }
    
    // Output the type definitions
    for (const auto& def_str : type_defs) {
        oss << def_str << "\n";
    }
    
    // Namespace close
    oss << generate_namespace_close() << "\n";
    
    // Header guard close
    oss << "#endif // " << guard << "\n";
    
    return oss.str();
}

std::string CppGenerator::generate_source() {
    // For now, implementations are inline in header
    // Future: generate .cpp file for complex methods
    return "";
}

std::string CppGenerator::generate_includes() {
    // Determine required includes based on types used
    add_include("<cstdint>");
    add_include("<string>");
    add_include("<variant>");
    add_include("<optional>");
    add_include("<vector>");
    add_include("<unordered_map>");
    
    std::ostringstream oss;
    oss << "// Generated by Carch IDL Compiler\n";
    oss << "// Do not edit manually\n\n";
    
    for (const auto& include : generated_includes_) {
        oss << "#include " << include << "\n";
    }
    
    return oss.str();
}

std::string CppGenerator::generate_namespace_open() {
    if (options_.namespace_name.empty()) {
        return "";
    }
    return "namespace " + options_.namespace_name + " {\n";
}

std::string CppGenerator::generate_namespace_close() {
    if (options_.namespace_name.empty()) {
        return "";
    }
    return "} // namespace " + options_.namespace_name + "\n";
}

std::string CppGenerator::generate_type_definition(parser::TypeDefinitionNode* def) {
    if (auto* struct_type = dynamic_cast<parser::StructTypeNode*>(def->type.get())) {
        return generate_struct(def->name, struct_type);
    } else if (auto* variant_type = dynamic_cast<parser::VariantTypeNode*>(def->type.get())) {
        return generate_variant(def->name, variant_type);
    } else if (auto* enum_type = dynamic_cast<parser::EnumTypeNode*>(def->type.get())) {
        return generate_enum(def->name, enum_type);
    }
    return "";
}

std::string CppGenerator::generate_struct(const std::string& name, parser::StructTypeNode* node) {
    std::ostringstream oss;
    
    oss << indent() << "struct " << to_pascal_case(name) << " {\n";
    increase_indent();
    
    for (auto& field : node->fields) {
        std::string context = to_pascal_case(name) + "_" + to_pascal_case(field->name);
        oss << indent() << map_type(field->type.get(), context) << " " << field->name << ";\n";
    }
    
    decrease_indent();
    oss << indent() << "};\n";
    
    return oss.str();
}

std::string CppGenerator::generate_variant(const std::string& name, parser::VariantTypeNode* node) {
    std::ostringstream oss;
    
    // First, generate named structs for each alternative with data
    for (auto& alt : node->alternatives) {
        if (alt->type) {
            std::string alt_type_name = to_pascal_case(name) + "_" + to_pascal_case(alt->name);
            oss << indent() << "struct " << alt_type_name << " {\n";
            increase_indent();
            
            if (auto* struct_type = dynamic_cast<parser::StructTypeNode*>(alt->type.get())) {
                for (auto& field : struct_type->fields) {
                    std::string context = alt_type_name + "_" + field->name;
                    oss << indent() << map_type(field->type.get(), context) << " " << field->name << ";\n";
                }
            } else {
                std::string context = alt_type_name + "_value";
                oss << indent() << map_type(alt->type.get(), context) << " value;\n";
            }
            
            decrease_indent();
            oss << indent() << "};\n\n";
        }
    }
    
    // Generate variant type using the named structs
    oss << indent() << "using " << to_pascal_case(name) << " = std::variant<\n";
    increase_indent();
    
    for (size_t i = 0; i < node->alternatives.size(); ++i) {
        auto& alt = node->alternatives[i];
        oss << indent();
        
        if (alt->type) {
            std::string alt_type_name = to_pascal_case(name) + "_" + to_pascal_case(alt->name);
            oss << alt_type_name;
        } else {
            // Unit type
            oss << "std::monostate /* " << alt->name << " */";
        }
        
        if (i < node->alternatives.size() - 1) {
            oss << ",";
        }
        oss << "\n";
    }
    
    decrease_indent();
    oss << indent() << ">;\n";
    
    return oss.str();
}

std::string CppGenerator::generate_enum(const std::string& name, parser::EnumTypeNode* node) {
    std::ostringstream oss;
    
    oss << indent() << "enum class " << to_pascal_case(name) << " {\n";
    increase_indent();
    
    for (size_t i = 0; i < node->values.size(); ++i) {
        oss << indent() << node->values[i];
        if (i < node->values.size() - 1) {
            oss << ",";
        }
        oss << "\n";
    }
    
    decrease_indent();
    oss << indent() << "};\n";
    
    return oss.str();
}

std::string CppGenerator::generate_field(parser::FieldNode* field) {
    return map_type(field->type.get(), "") + " " + field->name + ";";
}

std::string CppGenerator::map_type(parser::TypeExprNode* expr, const std::string& context) {
    if (auto* prim = dynamic_cast<parser::PrimitiveTypeNode*>(expr)) {
        return map_primitive_type(prim->primitive);
    } else if (auto* container = dynamic_cast<parser::ContainerTypeNode*>(expr)) {
        return map_container_type(container, context);
    } else if (auto* ref = dynamic_cast<parser::RefTypeNode*>(expr)) {
        return options_.use_strong_entity_id ? "entity_id" : "uint64_t";
    } else if (auto* id = dynamic_cast<parser::IdentifierTypeNode*>(expr)) {
        return to_pascal_case(id->name);
    } else if (auto* struct_type = dynamic_cast<parser::StructTypeNode*>(expr)) {
        return map_struct_type(struct_type);
    } else if (auto* variant_type = dynamic_cast<parser::VariantTypeNode*>(expr)) {
        return map_variant_type(variant_type);
    } else if (auto* enum_type = dynamic_cast<parser::EnumTypeNode*>(expr)) {
        return map_enum_type(enum_type, context);
    }
    return "void";
}

std::string CppGenerator::map_primitive_type(parser::PrimitiveType type) {
    switch (type) {
        case parser::PrimitiveType::STR: return "std::string";
        case parser::PrimitiveType::INT: return "int32_t";
        case parser::PrimitiveType::BOOL: return "bool";
        case parser::PrimitiveType::UNIT: return "std::monostate";
        case parser::PrimitiveType::U8: return "uint8_t";
        case parser::PrimitiveType::U16: return "uint16_t";
        case parser::PrimitiveType::U32: return "uint32_t";
        case parser::PrimitiveType::U64: return "uint64_t";
        case parser::PrimitiveType::I8: return "int8_t";
        case parser::PrimitiveType::I16: return "int16_t";
        case parser::PrimitiveType::I32: return "int32_t";
        case parser::PrimitiveType::I64: return "int64_t";
        case parser::PrimitiveType::F32: return "float";
        case parser::PrimitiveType::F64: return "double";
        default: return "int32_t";
    }
}

std::string CppGenerator::map_container_type(parser::ContainerTypeNode* node, const std::string& context) {
    if (node->kind == parser::ContainerKind::ARRAY) {
        return "std::vector<" + map_type(node->element_type.get(), context) + ">";
    } else if (node->kind == parser::ContainerKind::MAP) {
        return "std::unordered_map<" + map_type(node->key_type.get(), context + "_key") + ", " + 
               map_type(node->value_type.get(), context + "_value") + ">";
    } else if (node->kind == parser::ContainerKind::OPTIONAL) {
        return "std::optional<" + map_type(node->element_type.get(), context) + ">";
    }
    return "void";
}

std::string CppGenerator::map_struct_type(parser::StructTypeNode* node) {
    // Inline anonymous struct
    std::ostringstream oss;
    oss << "struct { ";
    for (size_t i = 0; i < node->fields.size(); ++i) {
        oss << map_type(node->fields[i]->type.get(), "") << " " << node->fields[i]->name;
        if (i < node->fields.size() - 1) oss << "; ";
    }
    oss << "; }";
    return oss.str();
}

std::string CppGenerator::map_variant_type(parser::VariantTypeNode* node) {
    // Inline anonymous variant - simplified
    std::ostringstream oss;
    oss << "std::variant<";
    for (size_t i = 0; i < node->alternatives.size(); ++i) {
        auto& alt = node->alternatives[i];
        if (alt->type) {
            oss << map_type(alt->type.get(), "");
        } else {
            oss << "std::monostate";
        }
        if (i < node->alternatives.size() - 1) oss << ", ";
    }
    oss << ">";
    return oss.str();
}

std::string CppGenerator::indent() {
    return std::string(current_indent_ * options_.indentation_size, ' ');
}

void CppGenerator::increase_indent() {
    current_indent_++;
}

void CppGenerator::decrease_indent() {
    if (current_indent_ > 0) {
        current_indent_--;
    }
}

std::string CppGenerator::to_pascal_case(const std::string& name) {
    if (name.empty()) return name;
    
    std::string result;
    bool capitalize_next = true;
    
    for (char c : name) {
        if (c == '_') {
            capitalize_next = true;
        } else if (capitalize_next) {
            result += std::toupper(c);
            capitalize_next = false;
        } else {
            result += c;
        }
    }
    
    return result;
}

std::string CppGenerator::sanitize_name(const std::string& name) {
    return name;
}

std::string CppGenerator::to_screaming_snake_case(const std::string& name) {
    std::string result;
    for (char c : name) {
        result += std::toupper(c);
    }
    return result;
}

std::string CppGenerator::generate_header_guard_name() {
    std::string guard = "CARCH_";
    if (!options_.namespace_name.empty()) {
        guard += to_screaming_snake_case(options_.namespace_name) + "_";
    }
    guard += to_screaming_snake_case(options_.output_basename) + "_H";
    
    // Replace non-alphanumerics with underscore
    for (char& c : guard) {
        if (!std::isalnum(c) && c != '_') {
            c = '_';
        }
    }
    return guard;
}

std::string CppGenerator::map_enum_type(parser::EnumTypeNode* node, const std::string& context) {
    // Generate a unique name for this anonymous enum
    std::string enum_name;
    if (!context.empty()) {
        enum_name = to_pascal_case(context) + "_Enum";
    } else {
        enum_name = "AnonymousEnum" + std::to_string(anonymous_type_counter_++);
    }
    
    // Hoist the enum definition
    hoisted_types_ << indent() << "enum class " << enum_name << " {\n";
    increase_indent();
    for (size_t i = 0; i < node->values.size(); ++i) {
        hoisted_types_ << indent() << node->values[i];
        if (i < node->values.size() - 1) {
            hoisted_types_ << ",";
        }
        hoisted_types_ << "\n";
    }
    decrease_indent();
    hoisted_types_ << indent() << "};\n\n";
    
    return enum_name;
}

void CppGenerator::add_include(const std::string& include) {
    generated_includes_.insert(include);
}

} // namespace codegen
} // namespace carch
